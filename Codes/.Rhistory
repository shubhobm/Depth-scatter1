lamwdiff
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
lamratio
cov(S)
# ARE for PD
Z = matrix(rt(1e6*pi, df=dfj), ncol=pi)
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
U = sweep(X, 1, nZ, FUN="/")
S = sweep(U,1,sqrtLambda,FUN="*")
W2 = (nz/(1+nz/c))^2
lamw = mean(W2)*colMeans(U^2/S^2)*lambda
lamwdiff = outer(lamw, lamw, FUN = "-")
W2
length(W2)
dim(sweep(S,2,W2,FUN="*"))
dim(sweep(S,1,W2,FUN="*"))
lamwdiff
colMeans(U^2/S^2)
colMeans(U^2)
length(W2)
length(W2^2)
crossprod(U)
crossprod(U)/crossprod(S)
colMeans(U^2/S^2
)
crossprod(S)
crossprod(S)/1e6
W2^2*crossprod(S)/1e6
dim(sweep(S,1,W2,FUN="*"))
crossprod(sweep(S,1,W2,FUN="*"))
crossprod(sweep(S,1,W2,FUN="*"))/1e6
crossprod(sweep(S,1,W2,FUN="*"))/n
n = 1e6
lamwdiff = outer(lamw, lamw, FUN = "-")
crossprod(sweep(S,1,W2,FUN="*"))/N
N = 1e6
crossprod(sweep(S,1,W2,FUN="*"))/N
lamwdiff
crossprod(sweep(S,1,W2,FUN="*"))/N/lamwdiff^2
diag(denom.mat) = 0
denom.mat = crossprod(sweep(S,1,W2,FUN="*"))/N/lamwdiff^2
diag(denom.mat) = 0
ARE.mat1[i,j] = lamratio_sum / sum(denom.mat)
lamratio_sum / sum(denom.mat)
lambda = rev(1:p)
sqrtLambda = sqrt(lambda)
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
diag(lamratio) = 0
lamratio_sum = sum(lamratio)
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
U = sweep(X, 1, nZ, FUN="/")
S = sweep(U,1,sqrtLambda,FUN="*")
W2 = (nz/(1+nz/c))^2
lamw = mean(W2)*colMeans(U^2/S^2)*lambda
lamwdiff = outer(lamw, lamw, FUN = "-")
denom.mat = crossprod(sweep(S,1,W2,FUN="*"))/N/lamwdiff^2
diag(denom.mat) = 0
lamratio_sum / sum(denom.mat)
sum(denom.mat)
denom.mat
crossprod(sweep(S,1,W2,FUN="*"))/N
lamwdiff^2
denom.mat
sum(denom.mat)
crossprod(sweep(S,1,W2,FUN="*"))/N
dim(crossprod(S))
crossprod(S)
crossprod(S)^2
W2
denom.mat = crossprod(sweep(S,1,W,FUN="*"))^2/N/lamwdiff
denom.mat
lamwdiff
denom.mat = crossprod(sweep(S,1,W,FUN="*"))^2/N/lamwdiff^2
diag(denom.mat) = 0
denom.mat
lamratio_sum / sum(denom.mat)
lamratio_sum
lamratio
S%*%S[1,]
S[1,]%*%S
S[,1]%*%S
lamratio
lamwdiff
lamratio
sum(lamratio[,1])
denom.mat
SS1 = S[,1] %*% S
SS1 = S %*% S[1,]
dim(SS1)
mean(W^4*SS1^2)
dim(S)
S[,1] %*% S
S[,1] %*% S/N
(S[,1] %*% S)^2/N
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
X = diag(sqrtLambda) %*% Z
X = Z %*% diag(sqrtLambda)
S = sweep(Z, 1, sqrt(rowSums(X^2)), FUN="/")
W = nZ/(1+nZ/c)
lamw = mean(W^2)*colMeans(U^2/S^2)*lambda
lamw
lamwdiff = outer(lamw, lamw, FUN = "-")
cov(S)
cov(S)*N
SS1 = cov(S)[,1]*N
mean(W^4*SS1^2)
lamratio
length(W)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
ws=sweep(S, 1, W, FUN="*")
dim(ws)
ws=sweep(S, 2, W, FUN="*")
SS1 = sweep(S, 2, S[,1], FUN="*")
SS1 = sweep(S, 1, S[,1], FUN="*")
dim(S)
SS1 = sweep(S, 1, S[,1], FUN="*")
length(W)
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = (nZ/(1+nZ/c))^2
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
lamw = mean(W2)*colMeans(U^2/S^2)*lambda
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(S, 1, W2*S[,1], FUN="*")
dim(W2SS1
)
colMeans(W2SS1)
colMeans(W2SS1^2)
lamwdiff
colMeans(W2SS1^2)
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]
denom.vec
lamwdiff[-1,1]
lamw
lamwdiff = outer(lamw, lamw, FUN = "-")
lamwdiff
colMeans(W2SS1^2)[-1]
lamratio
colMeans(W2SS1^2)[-1]
cov(sweep(S, 1, W, FUN="*"))
diag(cov(sweep(S, 1, W, FUN="*"))
)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
lamw = diag(cov(sweep(S, 1, W, FUN="*")))
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
lamwdiff
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]
colMeans(W2SS1^2)[-1]
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lamratio[-1,1]
sum(lamratio[-1,1]) / sum(denom.vec)
lamwdiff[-1,1]
outer(lambda,lambda,"-")[-1,1]
## Sim_efficiency: Asymptotic relative efficiency for depth-based scatter estimator
set.seed(03092016)
df.list = c(5,6,10,15,25,Inf)
p.list = c(2,5,10,20)
c = qnorm(.75)
N = 1e6
lambda = rev(1:p)
sqrtLambda = sqrt(lambda)
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
diag(lamratio) = 0
pi
dfj
pi = p.list[i]
dfj = df.list[j]
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
sum(lamratio[-1,1]) / sum(denom.vec)
lambda
max(W)
lamw
r = min(lambda)/max(lambda)^2
r
rw = min(lamw)/max(lamw)^2
rw
min(lambda)
min(lamw)
lambda = rev(1:p)
sqrtLambda = sqrt(lambda)
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
diag(lamratio) = 0
for(j in 1:length(df.list)){
pi = p.list[i]
dfj = df.list[j]
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
ARE.mat1[i,j] = sum(lamratio[-1,1]) / sum(denom.vec)
}
i=1
## Sim_efficiency: Asymptotic relative efficiency for depth-based scatter estimator
set.seed(03092016)
df.list = c(5,6,10,15,25,Inf)
p.list = c(2,5,10,20)
c = qnorm(.75)
N = 1e6
ARE.mat1 = matrix(0, nrow=length(p.list), ncol=length(df.list))
pi = p.list[i]
lambda = rev(1:pi)
sqrtLambda = sqrt(lambda)
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
diag(lamratio) = 0
for(j in 1:length(df.list)){
dfj = df.list[j]
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
ARE.mat1[i,j] = sum(lamratio[-1,1]) / sum(denom.vec)
}
ARE.mat1[1,]
lamw
p
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamw
cov(WS)
dim(WS)
dimW
dim(W)
dimS
dim(S)
p
pi
lamw
lamwdiff
pi=5
lambda = rev(1:pi)
sqrtLambda = sqrt(lambda)
lamratio = outer(lambda,lambda,"*")/outer(lambda,lambda,"-")^2
diag(lamratio) = 0
for(j in 1:length(df.list)){
dfj = df.list[j]
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
ARE.mat1[i,j] = sum(lamratio[-1,1]) / sum(denom.vec)
}
ARE.mat1[1,]
denom.vec
lamratio
?beta
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
dfj
c
j=1
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
c
qnorm(.75)
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
sum(lamratio[-1,1]) / sum(denom.vec)
pi
for(j in 1:length(df.list)){
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
ARE.mat1[i,j] = sum(lamratio[-1,1]) / sum(denom.vec)
}
ARE.mat1[1,]
lamw
lambda
W=1
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
#W = nZ/(1+nZ/c)
W=1
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
denom.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
denom.vec
lamratio
sum(lamratio[-1,1]) / sum(denom.vec)
(lamratio[-1,1]) / (denom.vec)
lamw
diag(cov(S))
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
d.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lam = diag(cov(S))
lamdiff = outer(lam, lam, FUN = "-")
SS1 = sweep(S, 1, S[,1], FUN="*")
n.vec = colMeans(SS1^2)[-1]/lamdiff[-1,1]^2
n.vec
d.vec
sum(n.vec) / sum(d.vec)
for(j in 1:length(df.list)){
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
d.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lam = diag(cov(S))
lamdiff = outer(lam, lam, FUN = "-")
SS1 = sweep(S, 1, S[,1], FUN="*")
n.vec = colMeans(SS1^2)[-1]/lamdiff[-1,1]^2
ARE.mat1[i,j] = sum(n.vec) / sum(d.vec)
}
ARE.mat1[1,]
summary(W)
for(j in 1:length(df.list)){
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
Fz = pt(nZ, df=dfj)
W = 1/nZ/(1+nZ/c)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
d.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lam = diag(cov(S))
lamdiff = outer(lam, lam, FUN = "-")
SS1 = sweep(S, 1, S[,1], FUN="*")
n.vec = colMeans(SS1^2)[-1]/lamdiff[-1,1]^2
ARE.mat1[i,j] = sum(n.vec) / sum(d.vec)
}
ARE.mat1[1,]
summary(W)
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
W = nZ/(1+nZ/c)
W = 1/(1+W)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
d.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lam = diag(cov(S))
lamdiff = outer(lam, lam, FUN = "-")
SS1 = sweep(S, 1, S[,1], FUN="*")
n.vec = colMeans(SS1^2)[-1]/lamdiff[-1,1]^2
ARE.mat1[i,j] = sum(n.vec) / sum(d.vec)
sum(n.vec) / sum(d.vec)
dfj = df.list[j]
# calculate MAD
if(dfj==Inf){
c = qnorm(.75)
} else{
c = 2*sqrt(dfj)/((dfj-1)*beta(dfj/2,1/2))
}
# ARE for PD
Z = matrix(rt(N*pi, df=dfj), ncol=pi)
U = sweep(Z, 1, nZ, FUN="/")
nZ = sqrt(rowSums(Z^2))
W = nZ/(1+nZ/c)
W = exp(-W)
X = Z %*% diag(sqrtLambda)
S = sweep(X, 1, sqrt(rowSums(X^2)), FUN="/")
WS = sweep(S, 1, W, FUN="*")
lamw = diag(cov(WS))
lamwdiff = outer(lamw, lamw, FUN = "-")
W2SS1 = sweep(WS, 1, WS[,1], FUN="*")
d.vec = colMeans(W2SS1^2)[-1]/lamwdiff[-1,1]^2
lam = diag(cov(S))
lamdiff = outer(lam, lam, FUN = "-")
SS1 = sweep(S, 1, S[,1], FUN="*")
n.vec = colMeans(SS1^2)[-1]/lamdiff[-1,1]^2
sum(n.vec) / sum(d.vec)
